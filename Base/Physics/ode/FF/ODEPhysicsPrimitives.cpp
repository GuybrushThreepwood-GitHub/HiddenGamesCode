
/*===================================================================
	File: ODEPhysicsPrimitives.cpp
	Library: Physics

	(C)Hidden Games
=====================================================================*/

#ifdef BASE_SUPPORT_ODE
#if defined(BASE_SUPPORT_OPENGL) || defined(BASE_SUPPORT_OPENGLES)

#include "CoreBase.h"
#include "MathBase.h"
#include "CollisionBase.h"
#include "RenderBase.h"

#include <cmath>

#include "Physics/ode/FF/ODEPhysicsPrimitives.h"
#include "Physics/ode/PhysicsWorldODE.h"

namespace
{
	GLuint physicsTexture = renderer::INVALID_OBJECT;

	static int capped_cylinder_quality = 3;
	static int sphere_quality = 1;

	const int MAX_POINTS = 256;
	int pointIndex = 0;

	GLfloat m[16];

	math::Vec3 vaNormals[MAX_POINTS];
	math::Vec3 vaPoints[MAX_POINTS];

	bool showAABBs = false;
	bool showPhysicsBodies = true;
	bool showContacts = false;

	//dGeomID planeGeom = 0;
}

/////////////////////////////////////////////////////
/// Function: SetTransform
/// Params: [in]pos [in]R
///
/////////////////////////////////////////////////////
void physics::SetTransform( const float pos[3], const float R[12] )
{
	m[0] = R[0];
	m[1] = R[4];
	m[2] = R[8];
	m[3] = 0.0f;
	m[4] = R[1];
	m[5] = R[5];
	m[6] = R[9];
	m[7] = 0.0f;
	m[8] = R[2];
	m[9] = R[6];
	m[10] = R[10];
	m[11] = 0.0f;
	m[12] = pos[0];
	m[13] = pos[1];
	m[14] = pos[2];
	m[15] = 1.0f;

	glMultMatrixf( m );
}

/////////////////////////////////////////////////////
/// Function: PhysicsPrimitiveDrawBox
/// Params: [in]sides
///
/////////////////////////////////////////////////////
void physics::PhysicsPrimitiveDrawBox( const float sides[3] )
{
	float lx = sides[0]*0.5f;
	float ly = sides[1]*0.5f;
	float lz = sides[2]*0.5f;

	// sides

	vaPoints[0] = math::Vec3(-lx, -ly, -lz);
	vaPoints[1] = math::Vec3(-lx, -ly, lz);
	vaPoints[2] = math::Vec3(-lx, ly, -lz);
	vaPoints[3] = math::Vec3(-lx, ly, lz);

	vaPoints[4] = math::Vec3(lx, ly, -lz);
	vaPoints[5] = math::Vec3(lx, ly, lz);

	vaPoints[6] = math::Vec3(lx, -ly, -lz);
	vaPoints[7] = math::Vec3(lx, -ly, lz);

	vaPoints[8] = math::Vec3(-lx, -ly, -lz);
	vaPoints[9] = math::Vec3(-lx, -ly, lz);

	vaNormals[0] = math::Vec3(-1.0f, 0.0f, 0.0f);
	vaNormals[1] = math::Vec3(-1.0f, 0.0f, 0.0f);
	vaNormals[2] = math::Vec3(-1.0f, 0.0f, 0.0f);
	vaNormals[3] = math::Vec3(-1.0f, 0.0f, 0.0f);

	vaNormals[4] = math::Vec3(0.0f, 1.0f, 0.0f);
	vaNormals[5] = math::Vec3(0.0f, 1.0f, 0.0f);

	vaNormals[6] = math::Vec3(1.0f,0.0f,0.0f);
	vaNormals[7] = math::Vec3(1.0f,0.0f,0.0f);

	vaNormals[8] = math::Vec3(0.0f,-1.0f,0.0f);
	vaNormals[9] = math::Vec3(0.0f,-1.0f,0.0f);

	glNormalPointer(GL_FLOAT, sizeof(math::Vec3), vaNormals);
	glVertexPointer(3, GL_FLOAT, sizeof(math::Vec3), vaPoints);
	glDrawArrays(GL_TRIANGLE_STRIP, 0, 10 );

	// top face
	vaPoints[0] = math::Vec3(-lx, -ly, lz);
	vaPoints[1] = math::Vec3(lx, -ly, lz);
	vaPoints[2] = math::Vec3(lx, ly, lz);
	vaPoints[3] = math::Vec3(-lx, ly, lz);

	vaNormals[0] = math::Vec3(0.0f, 0.0f, 1.0f);
	vaNormals[1] = math::Vec3(0.0f, 0.0f, 1.0f);
	vaNormals[2] = math::Vec3(0.0f, 0.0f, 1.0f);
	vaNormals[3] = math::Vec3(0.0f, 0.0f, 1.0f);

	glNormalPointer(GL_FLOAT, sizeof(math::Vec3), vaNormals);
	glVertexPointer(3, GL_FLOAT, sizeof(math::Vec3), vaPoints);
	glDrawArrays(GL_TRIANGLE_FAN, 0, 4 );

	// bottom face
	vaPoints[0] = math::Vec3(-lx, -ly, -lz);
	vaPoints[1] = math::Vec3(-lx, ly, -lz);
	vaPoints[2] = math::Vec3(lx, ly, -lz);
	vaPoints[3] = math::Vec3(lx, -ly, -lz);

	vaNormals[0] = math::Vec3(0.0f, 0.0f, -1.0f);
	vaNormals[1] = math::Vec3(0.0f, 0.0f, -1.0f);
	vaNormals[2] = math::Vec3(0.0f, 0.0f, -1.0f);
	vaNormals[3] = math::Vec3(0.0f, 0.0f, -1.0f);

	glNormalPointer(GL_FLOAT, sizeof(math::Vec3), vaNormals);
	glVertexPointer(3, GL_FLOAT, sizeof(math::Vec3), vaPoints);
	glDrawArrays(GL_TRIANGLE_FAN, 0, 4 );
}

/////////////////////////////////////////////////////
/// Function: PhysicsPrimitiveDrawPatch
/// Params: [in]p1, [in]p2, [in]p3
// This is recursively subdivides a triangular area (vertices p1,p2,p3) into
// smaller triangles, and then draws the triangles. All triangle vertices are
// normalized to a distance of 1.0 from the origin (p1,p2,p3 are assumed
// to be already normalized). Note this is not super-fast because it draws
// triangles rather than triangle strips.
/////////////////////////////////////////////////////
void physics::PhysicsPrimitiveDrawPatch( float p1[3], float p2[3], float p3[3], int level )
{
	int i;
	if( level > 0 ) 
	{
		float q1[3], q2[3], q3[3];		 // sub-vertices
		for( i = 0; i < 3; i++ ) 
		{
			q1[i] = 0.5f*(p1[i] + p2[i]);
			q2[i] = 0.5f*(p2[i] + p3[i]);
			q3[i] = 0.5f*(p3[i] + p1[i]);
		}
		float length1 = (float)(1.0f / std::sqrt(q1[0]*q1[0]+q1[1]*q1[1]+q1[2]*q1[2]));
		float length2 = (float)(1.0f / std::sqrt(q2[0]*q2[0]+q2[1]*q2[1]+q2[2]*q2[2]));
		float length3 = (float)(1.0f / std::sqrt(q3[0]*q3[0]+q3[1]*q3[1]+q3[2]*q3[2]));
		for( i = 0; i < 3; i++ ) 
		{
			q1[i] *= length1;
			q2[i] *= length2;
			q3[i] *= length3;
		}
		physics::PhysicsPrimitiveDrawPatch( p1, q1, q3, level-1 );
		physics::PhysicsPrimitiveDrawPatch( q1, p2, q2, level-1 );
		physics::PhysicsPrimitiveDrawPatch( q1, q2, q3, level-1 );
		physics::PhysicsPrimitiveDrawPatch( q3, q2, p3, level-1 );
	}
	else 
	{
		vaPoints[pointIndex] = math::Vec3( p1[0], p1[1], p1[2] );
		vaPoints[pointIndex+1] = math::Vec3( p2[0], p2[1], p2[2] );
		vaPoints[pointIndex+2] = math::Vec3( p3[0], p3[1], p3[2] );
		
		vaNormals[pointIndex] = math::Vec3( p1[0], p1[1], p1[2] );
		vaNormals[pointIndex+1] = math::Vec3( p2[0], p2[1], p2[2] );
		vaNormals[pointIndex+2] = math::Vec3(p3[0], p3[1], p3[2]);

		pointIndex+=3;
	}
}

/////////////////////////////////////////////////////
/// Function: drawSphere
/// Params: None
///
/////////////////////////////////////////////////////
void physics::PhysicsPrimitiveDrawSphere( void )
{
	// icosahedron data for an icosahedron of radius 1.0
const float ICX		= 0.525731112119133606f;
const float ICZ		= 0.850650808352039932f;
	static GLfloat idata[12][3] = 
	{
		{-ICX, 0.0f, ICZ},
		{ICX, 0.0f, ICZ},
		{-ICX, 0.0f, -ICZ},
		{ICX, 0.0f, -ICZ},
		{0.0f, ICZ, ICX},
		{0.0f, ICZ, -ICX},
		{0.0f, -ICZ, ICX},
		{0.0f, -ICZ, -ICX},
		{ICZ, ICX, 0.0f},
		{-ICZ, ICX, 0.0f},
		{ICZ, -ICX, 0.0f},
		{-ICZ, -ICX, 0.0f}
	};

	static int index[20][3] = 
	{
		{0, 4, 1},	  {0, 9, 4},
		{9, 5, 4},	  {4, 5, 8},
		{4, 8, 1},	  {8, 10, 1},
		{8, 3, 10},   {5, 3, 8},
		{5, 2, 3},	  {2, 7, 3},
		{7, 10, 3},   {7, 6, 10},
		{7, 11, 6},   {11, 0, 6},
		{0, 1, 6},	  {6, 1, 10},
		{9, 0, 11},   {9, 11, 2},
		{9, 2, 5},	  {7, 2, 11},
	};

	pointIndex = 0;
	for( int i = 0; i < 20; i++ ) 
	{
		physics::PhysicsPrimitiveDrawPatch( &idata[index[i][2]][0], &idata[index[i][1]][0], &idata[index[i][0]][0], sphere_quality );
	}
	DBG_ASSERT( pointIndex < MAX_POINTS );
	
	glNormalPointer(GL_FLOAT, sizeof(math::Vec3), vaNormals);
	glVertexPointer(3, GL_FLOAT, sizeof(math::Vec3), vaPoints);
	glDrawArrays(GL_TRIANGLES, 0, pointIndex );
	pointIndex = 0;
}

/////////////////////////////////////////////////////
/// Function: PhysicsPrimitiveDrawTriangle
/// Params: [in]v0, [in]v1, [in]v2, [in]solid
///
/////////////////////////////////////////////////////
void physics::PhysicsPrimitiveDrawTriangle( const float *v0, const float *v1, const float *v2, int solid )
{
	float u[3], v[3], normal[3];

	u[0] = v1[0] - v0[0];
	u[1] = v1[1] - v0[1];
	u[2] = v1[2] - v0[2];
	v[0] = v2[0] - v0[0];
	v[1] = v2[1] - v0[1];
	v[2] = v2[2] - v0[2];
	
	dCROSS( normal, =, u, v );
	math::Normalise(normal);

	vaPoints[0] = math::Vec3(v0[0], v0[1], v0[2]);
	vaPoints[1] = math::Vec3(v1[0], v1[1], v1[2]);
	vaPoints[2] = math::Vec3(v2[0], v2[1], v2[2]);

	vaNormals[0] = math::Vec3(normal[0], normal[1], normal[2]);
	vaNormals[1] = math::Vec3(normal[0], normal[1], normal[2]);
	vaNormals[2] = math::Vec3(normal[0], normal[1], normal[2]);

	glNormalPointer(GL_FLOAT, sizeof(math::Vec3), vaNormals);
	glVertexPointer(3, GL_FLOAT, sizeof(math::Vec3), vaPoints);
	glDrawArrays(solid ? GL_TRIANGLES : GL_LINE_STRIP, 0, 3 );
}

/////////////////////////////////////////////////////
/// Function: PhysicsPrimitiveDrawCappedCylinder
/// Params: [in]l, [in]r
///
/////////////////////////////////////////////////////
void physics::PhysicsPrimitiveDrawCappedCylinder( float l, float r )
{
	int i,j;
	float tmp, nx, ny, nz, start_nx, start_ny, a, ca, sa;
	// number of sides to the cylinder (divisible by 4):
	const int n = capped_cylinder_quality*4;

	l *= 0.5f;
	a = float(math::PI*2.0f)/float(n);
	sa = std::sin(a);
	ca = std::cos(a);

	// draw cylinder body
	pointIndex = 0;

	ny = 1.0f; nz = 0.0f;		  // normal vector = (0,ny,nz)

		for( i = 0; i <= n; i++ ) 
		{
			vaPoints[pointIndex] = math::Vec3( ny*r, nz*r, l );
			vaPoints[pointIndex+1] = math::Vec3( ny*r, nz*r, -l );

			vaNormals[pointIndex] = math::Vec3( ny, nz, 0.0f );
			vaNormals[pointIndex+1] = math::Vec3( ny, nz, 0.0f );

			pointIndex += 2;

			// rotate ny,nz
			tmp = ca*ny - sa*nz;
			nz = sa*ny + ca*nz;
			ny = tmp;
		}

	glNormalPointer( GL_FLOAT, sizeof(math::Vec3), vaNormals);
	glVertexPointer(3, GL_FLOAT, sizeof(math::Vec3), vaPoints);
	glDrawArrays( GL_TRIANGLE_STRIP, 0, pointIndex );

	// draw first cylinder cap
	start_nx = 0.0f;
	start_ny = 1.0f;
	for( j = 0; j < (n/4); j++ ) 
	{
		pointIndex = 0;

		// get start_n2 = rotated start_n
		float start_nx2 =  ca*start_nx + sa*start_ny;
		float start_ny2 = -sa*start_nx + ca*start_ny;
		// get n=start_n and n2=start_n2
		nx = start_nx; ny = start_ny; nz = 0.0f;
		float nx2 = start_nx2, ny2 = start_ny2, nz2 = 0.0f;

			for( i = 0; i <= n; i++ ) 
			{
				vaPoints[pointIndex] = math::Vec3( ny2*r, nz2*r, l+nx2*r );
				vaPoints[pointIndex+1] = math::Vec3( ny*r, nz*r, l+nx*r );

				vaNormals[pointIndex] = math::Vec3( ny2, nz2, nx2 );
				vaNormals[pointIndex+1] = math::Vec3( ny, nz, nx );

				pointIndex += 2;

				// rotate n,n2
				tmp = ca*ny - sa*nz;
				nz = sa*ny + ca*nz;
				ny = tmp;
				tmp = ca*ny2- sa*nz2;
				nz2 = sa*ny2 + ca*nz2;
				ny2 = tmp;
			}
		
		glNormalPointer(GL_FLOAT, sizeof(math::Vec3), vaNormals);
		glVertexPointer(3, GL_FLOAT, sizeof(math::Vec3), vaPoints);
		glDrawArrays( GL_TRIANGLE_STRIP, 0, pointIndex );

		start_nx = start_nx2;
		start_ny = start_ny2;
	}

	// draw second cylinder cap
	start_nx = 0.0f;
	start_ny = 1.0f;
	for( j = 0; j < (n/4); j++ ) 
	{
		pointIndex = 0;

		// get start_n2 = rotated start_n
		float start_nx2 = ca*start_nx - sa*start_ny;
		float start_ny2 = sa*start_nx + ca*start_ny;
		// get n=start_n and n2=start_n2
		nx = start_nx; ny = start_ny; nz = 0.0f;
		float nx2 = start_nx2, ny2 = start_ny2, nz2 = 0.0f;
			for( i = 0; i <= n; i++ ) 
			{
				vaPoints[pointIndex] = math::Vec3( ny*r, nz*r, -l+nx*r );
				vaPoints[pointIndex+1] = math::Vec3( ny2*r, nz2*r, -l+nx2*r );

				vaNormals[pointIndex] = math::Vec3( ny, nz, nx );
				vaNormals[pointIndex+1] = math::Vec3( ny2, nz2, nx2 );

				pointIndex += 2;

				// rotate n,n2
				tmp = ca*ny - sa*nz;
				nz = sa*ny + ca*nz;
				ny = tmp;
				tmp = ca*ny2- sa*nz2;
				nz2 = sa*ny2 + ca*nz2;
				ny2 = tmp;
			}
			
		glNormalPointer(GL_FLOAT, sizeof(math::Vec3), vaNormals);
		glVertexPointer(3, GL_FLOAT, sizeof(math::Vec3), vaPoints);
		glDrawArrays( GL_TRIANGLE_STRIP, 0, pointIndex );

		start_nx = start_nx2;
		start_ny = start_ny2;
	}
}


// draw a cylinder of length l and radius r, aligned along the z axis
/////////////////////////////////////////////////////
/// Function: PhysicsPrimitiveDrawCylinder
/// Params: [in]l, [in]r, [in]zoffset
///
/////////////////////////////////////////////////////
void physics::PhysicsPrimitiveDrawCylinder( float l, float r, float zoffset )
{
	int i;
	float tmp,ny,nz,a,ca,sa;
	const int n = 24;	// number of sides to the cylinder (divisible by 4)

	l *= 0.5f;
	a = float(math::PI*2.0f)/float(n);
	sa = std::sin(a);
	ca = std::cos(a);

	// draw cylinder body
	pointIndex = 0;

	ny = 1.0f; nz = 0.0f;		  // normal vector = (0,ny,nz)

		for( i = 0; i <= n; i++ ) 
		{
			vaPoints[pointIndex] = math::Vec3( ny*r, nz*r, l+zoffset );
			vaPoints[pointIndex+1] = math::Vec3( ny*r, nz*r, -l+zoffset );

			vaNormals[pointIndex] = math::Vec3( ny, nz, 0.0f );
			vaNormals[pointIndex+1] = math::Vec3( ny, nz, 0.0f );

			pointIndex += 2;

			// rotate ny,nz
			tmp = ca*ny - sa*nz;
			nz = sa*ny + ca*nz;
			ny = tmp;
		}

	glNormalPointer(GL_FLOAT, sizeof(math::Vec3), vaNormals);
	glVertexPointer(3, GL_FLOAT, sizeof(math::Vec3), vaPoints);
	glDrawArrays( GL_TRIANGLE_STRIP, 0, pointIndex );

	// draw top cap
	pointIndex = 0;
	ny = 1.0f; nz = 0.0f;		  // normal vector = (0,ny,nz)

		vaPoints[pointIndex] = math::Vec3( 0.0f, 0.0f, l+zoffset );
		vaNormals[pointIndex] = math::Vec3( 0.0f, 0.0f, 1.0f );

		pointIndex++;
		for( i = 0; i <= n; i++ ) 
		{
			vaPoints[pointIndex] = math::Vec3( ny*r, nz*r, l+zoffset );
			vaNormals[pointIndex] = math::Vec3( 0.0f, 0.0f, 1.0f );

			pointIndex++;

			// rotate ny,nz
			tmp = ca*ny - sa*nz;
			nz = sa*ny + ca*nz;
			ny = tmp;
		}

	glNormalPointer(GL_FLOAT, sizeof(math::Vec3), vaNormals);
	glVertexPointer(3, GL_FLOAT, sizeof(math::Vec3), vaPoints);
	glDrawArrays( GL_TRIANGLE_FAN, 0, pointIndex );

	// draw bottom cap
	pointIndex = 0;
	ny = 1.0f; nz = 0.0f;		  // normal vector = (0,ny,nz)

		vaPoints[pointIndex] = math::Vec3( 0.0f, 0.0f, -l+zoffset );
		vaNormals[pointIndex] = math::Vec3( 0.0f, 0.0f, -1.0f );

		pointIndex++;

		for( i = 0; i <= n; i++ ) 
		{
			vaPoints[pointIndex] = math::Vec3( ny*r, nz*r, -l+zoffset );
			vaNormals[pointIndex] = math::Vec3( 0.0f, 0.0f, -1.0f );

			pointIndex++;

			// rotate ny,nz
			tmp = ca*ny + sa*nz;
			nz = -sa*ny + ca*nz;
			ny = tmp;
		}

	glNormalPointer(GL_FLOAT, sizeof(math::Vec3), vaNormals);
	glVertexPointer(3, GL_FLOAT, sizeof(math::Vec3), vaPoints);
	glDrawArrays( GL_TRIANGLE_FAN, 0, pointIndex );
}

/////////////////////////////////////////////////////
/// Function: DrawBox
/// Params: [in]pos, [in]R, [in]sides
///
/////////////////////////////////////////////////////
void physics::DrawBox( const float pos[3], const float R[12], const float sides[3] )
{
	glPushMatrix();
		physics::SetTransform( pos, R );
		physics::PhysicsPrimitiveDrawBox( sides );
	glPopMatrix();
}

/////////////////////////////////////////////////////
/// Function: DrawSphere
/// Params: [in]pos, [in]R, [in]radius
///
/////////////////////////////////////////////////////
void physics::DrawSphere( const float pos[3], const float R[12], float radius )
{
	glPushMatrix();
		physics::SetTransform( pos, R );
		glScalef( radius, radius, radius );
		glEnable(GL_NORMALIZE); // because it's scaled
		physics::PhysicsPrimitiveDrawSphere();
		glDisable(GL_NORMALIZE);
	glPopMatrix();
}

/////////////////////////////////////////////////////
/// Function: DrawTriangle
/// Params: [in]pos, [in]R, [in]v0, [in]v2, [in]v2, [in]solid
///
/////////////////////////////////////////////////////
void physics::DrawTriangle( const float pos[3], const float R[12], const float *v0, const float *v1, const float *v2, int solid )
{
	glPushMatrix();
		physics::SetTransform( pos, R );
		physics::PhysicsPrimitiveDrawTriangle( v0, v1, v2, solid );
	glPopMatrix();
}

/////////////////////////////////////////////////////
/// Function: DrawCylinder
/// Params: [in]pos, [in]R, [in]length, [in]radius
///
/////////////////////////////////////////////////////
void physics::DrawCylinder( const float pos[3], const float R[12], float length, float radius )
{
	glPushMatrix();
		physics::SetTransform( pos, R );
		physics::PhysicsPrimitiveDrawCylinder( length, radius, 0.0f );
	glPopMatrix();
}

/////////////////////////////////////////////////////
/// Function: DrawCappedCylinder
/// Params: [in]pos, [in]R, [in]length, [in]radius
///
/////////////////////////////////////////////////////
void physics::DrawCappedCylinder( const float pos[3], const float R[12], float length, float radius )
{
	glPushMatrix();
		physics::SetTransform( pos, R );
		physics::PhysicsPrimitiveDrawCappedCylinder( length, radius );
	glPopMatrix();
}

/////////////////////////////////////////////////////
/// Function: DrawLine
/// Params: [in]pos1, [in]pos2
///
/////////////////////////////////////////////////////
void physics::DrawLine( const float pos1[3], const float pos2[3] )
{
	vaPoints[0] = math::Vec3( pos1[0], pos1[1], pos1[2] );
	vaPoints[0] = math::Vec3( pos2[0], pos2[1], pos2[2] );

	vaNormals[0] = math::Vec3( 0.0f, 1.0f, 0.0f );
	vaNormals[1] = math::Vec3( 0.0f, 1.0f, 0.0f );

	glNormalPointer(GL_FLOAT, sizeof(math::Vec3), vaNormals);
	glVertexPointer(3, GL_FLOAT, sizeof(math::Vec3), vaPoints);
	glDrawArrays( GL_LINES, 0, 2 );

	//glLineWidth(2.0f);
	//glBegin( GL_LINES );
	//	glVertex3f( pos1[0], pos1[1], pos1[2] );
	//	glVertex3f( pos2[0], pos2[1], pos2[2] );
	//glEnd();
	//glLineWidth(1.0f);
}

/////////////////////////////////////////////////////
/// Function: DrawPhysicsGeometry
/// Params: [in]g, [in]pos, [in]R
///
/////////////////////////////////////////////////////
void physics::DrawPhysicsGeometry( dGeomID g, const dReal *pos, const dReal *R )
{
	int i;
	
	if( !showPhysicsBodies )
		return;

	if(!g)
		return;

	bool textureState = renderer::OpenGL::GetInstance()->GetTextureState();
	if( textureState )
		renderer::OpenGL::GetInstance()->DisableTexturing();

	renderer::OpenGL::GetInstance()->DisableVBO();

	renderer::OpenGL::GetInstance()->SetColour4f( 1.0f, 0.0f, 1.0f, 1.0f );

	math::Vec4 matAmbient( 0.0f, 0.0f, 0.0f, 1.0f );
	math::Vec4 matColour( 1.0f, 0.0f, 1.0f, 1.0f );
	math::Vec4 matSpec( 1.0f, 1.0f, 1.0f, 1.0f );
	renderer::OpenGL::GetInstance()->SetMaterialAmbient(matAmbient);
	renderer::OpenGL::GetInstance()->SetMaterialDiffuse(matColour);
	renderer::OpenGL::GetInstance()->SetMaterialSpecular(matSpec);
	renderer::OpenGL::GetInstance()->SetMaterialShininess(10.0f);
	renderer::OpenGL::GetInstance()->EnableNormalArray();

#ifdef BASE_ENABLE_ODE_TEXTURE
	BindODETexture();
#endif // BASE_ENABLE_ODE_TEXTURE

	if(!pos) 
		pos = dGeomGetPosition(g);
	if(!R) 
		R = dGeomGetRotation(g);

	int type = dGeomGetClass(g);

	if( type == dRayClass ) 
	{
		dReal len;
		dVector3 start, dir;
		len = dGeomRayGetLength( g );

		dGeomRayGet( g, start, dir );
		dir[0] = dir[0]*len;
		dir[1] = dir[1]*len;
		dir[2] = dir[2]*len;

		physics::DrawLine( start, dir );
	}
	else if( type == dBoxClass ) 
	{
		dVector3 sides;
		dGeomBoxGetLengths( g, sides );

		physics::DrawBox( pos, R, sides );
	}
	else if( type == dSphereClass ) 
	{
		float scaledRadius = dGeomSphereGetRadius (g);

		physics::DrawSphere(pos,R, scaledRadius);
	}
	else if( type == dCCylinderClass ) 
	{
		dReal radius,length;
		dGeomCCylinderGetParams( g, &radius, &length );
		physics::DrawCappedCylinder( pos, R, length, radius );
	}
	else if( type == dCylinderClass ) 
	{
		dReal radius,length;
		dGeomCylinderGetParams( g, &radius, &length );
		physics::DrawCylinder( pos, R, length, radius );
	}
	else if (type == dGeomTransformClass) 
	{
		dGeomID g2 = dGeomTransformGetGeom(g);
		const dReal *pos2 = dGeomGetPosition(g2);
		const dReal *R2 = dGeomGetRotation(g2);
		dVector3 actual_pos;
		dMatrix3 actual_R;
		dMULTIPLY0_331( actual_pos, R, pos2 );
		actual_pos[0] += pos[0];
		actual_pos[1] += pos[1];
		actual_pos[2] += pos[2];
		dMULTIPLY0_333( actual_R, R, R2 );

		DrawPhysicsGeometry( g2, actual_pos, actual_R );
	}

	if( showAABBs ) 
	{
		math::Vec4Lite col = renderer::OpenGL::GetInstance()->GetColour4ub();

		renderer::OpenGL::GetInstance()->SetColour4ub( 0, 0, 255, 128 );
		renderer::OpenGL::GetInstance()->BlendMode( true, GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA );

		// draw the bounding box for this geom
		dReal aabb[6];
		dGeomGetAABB( g, aabb );

		dVector3 bbpos;
		for( i = 0; i < 3; i++ ) 
			bbpos[i] = 0.5f*(aabb[i*2] + aabb[i*2+1]);

		dVector3 bbsides;
		for( i = 0; i < 3; i++ ) 
			bbsides[i] = aabb[i*2+1] - aabb[i*2];

		dMatrix3 RI;
		dRSetIdentity(RI);

		physics::DrawBox( bbpos, RI, bbsides );

		renderer::OpenGL::GetInstance()->SetColour4ub( col.R, col.G, col.B, col.A );
		renderer::OpenGL::GetInstance()->BlendMode( false, GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA );
	}

	if( textureState )
		renderer::OpenGL::GetInstance()->EnableTexturing();

	renderer::OpenGL::GetInstance()->DisableNormalArray();
}

/////////////////////////////////////////////////////
/// Function: DrawPhysicsPlane
/// Params: None
///
/////////////////////////////////////////////////////
void physics::DrawPhysicsPlane()
{
	float fFarClip = 10.0f;
	math::Vec3 vEye, vCenter;
	renderer::TGLCullFaceState SavedCullState;

	bool lightingState = renderer::OpenGL::GetInstance()->GetLightingState();
	bool textureState = renderer::OpenGL::GetInstance()->GetTextureState();

	renderer::OpenGL::GetInstance()->DisableLighting();
	renderer::OpenGL::GetInstance()->GetLookAt( vEye, vCenter );
	renderer::OpenGL::GetInstance()->GetFOVNearFarClip( 0, 0, &fFarClip );

	renderer::OpenGL::GetInstance()->SaveCullState( &SavedCullState );
	renderer::OpenGL::GetInstance()->SetCullState( false, GL_BACK );

#ifdef BASE_ENABLE_ODE_TEXTURE
		glClientActiveTexture( GL_TEXTURE0 );
		glEnableClientState( GL_TEXTURE_COORD_ARRAY );
	BindODETexture();
#else
	renderer::OpenGL::GetInstance()->DisableTexturing();
#endif // BASE_ENABLE_ODE_TEXTURE

	// grid			
		GLfloat planePoints[] = 
		{ 
			-fFarClip,  0.0f, -fFarClip,
			fFarClip,  0.0f, -fFarClip,
			-fFarClip,  0.0f, fFarClip,
			fFarClip,  0.0f, fFarClip
		};
			
		GLfloat uvCoords[] = 
		{ 
			0.0f, 0.0f,
			0.0f, fFarClip/2.0f, 
			fFarClip/2.0f, 0.0f, 
			fFarClip/2.0f, fFarClip/2.0f
		};
		glVertexPointer(3, GL_FLOAT, 0, planePoints);
		glTexCoordPointer(2, GL_FLOAT, sizeof( GLfloat )*2, uvCoords );
		glDrawArrays(GL_TRIANGLE_STRIP, 0, 4 );

	renderer::OpenGL::GetInstance()->SetCullState( &SavedCullState );
	glClientActiveTexture( GL_TEXTURE0 );
		glDisableClientState( GL_TEXTURE_COORD_ARRAY );

	if( textureState )
		renderer::OpenGL::GetInstance()->EnableTexturing();

	if( lightingState )
		renderer::OpenGL::GetInstance()->EnableLighting();
}

/////////////////////////////////////////////////////
/// Function: CreatePlane
/// Params: [in]a, [in]b, [in]c, [in]d
///
/////////////////////////////////////////////////////
dGeomID physics::CreatePlane( float a, float b, float c, float d )
{
	return dCreatePlane( physics::PhysicsWorldODE::GetSpace(), a, b, c, d );
}

/////////////////////////////////////////////////////
/// Function: ShowAABBs
/// Params: [in]state
///
/////////////////////////////////////////////////////
void physics::ShowAABBs( bool state )
{
	showAABBs = state;
}

/////////////////////////////////////////////////////
/// Function: ShowPhysicsBodies
/// Params: [in]state
///
/////////////////////////////////////////////////////
void physics::ShowPhysicsBodies( bool state )
{
	showPhysicsBodies = state;
}


///////////////////////////////////////////////////////////////////////////////////////////////////

#ifdef BASE_ENABLE_ODE_TEXTURE

unsigned char physics_texture[32*32*3] = {
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 
0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 
0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 
0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 
0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 
0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0, 0x80, 0x80, 
0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 
0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 
0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 
0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 
0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 
0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 
0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 
0x0, 0x80, 0x80, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 
0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 
0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 
0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0x0, 0x0, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0, 0x0, 0x0, 0xff, 0xff, 0xff, 0x0, 0x0, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0x0, 0x0, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x80, 0x80, 0x0, 0x0, 0x0, 0x0, 0x80, 0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 
0x0, 0x0, 0x0, 0x0, 0x80, 0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0x0, 0x0, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0, 0x0, 0x0, 0xff, 0xff, 0xff, 0x0, 0x0, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0, 0x0, 0x0, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x0, 0x0, 0x0, 0x80, 0x80, 0x0, 0x0, 0x0, 0x0, 0x80, 0x80, 0x0, 0x0, 0x0, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 
0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x0, 0x0, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0, 0x0, 0x0, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0, 0x0, 0x0, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x80, 0x80, 0x0, 0x0, 0x0, 0x0, 0x80, 0x80, 0x0, 0x0, 0x0, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 
0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 
0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xff, 0xff, 0xff, 0x0, 0x0, 0x0, 0xff, 0xff, 0xff, 0x0, 0x0, 0x0, 0xff, 0xff, 0xff, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xff, 0xff, 0xff, 
0x0, 0x0, 0x0, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x0, 0x0, 0x0, 0x80, 0x80, 0x0, 0x0, 0x0, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x0, 0x0, 
0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0, 0x0, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0x0, 0x0, 0x0, 0xff, 0xff, 0xff, 0x0, 0x0, 0x0, 0xff, 0xff, 0xff, 0x0, 0x0, 0x0, 0xff, 0xff, 0xff, 0x0, 0x0, 0x0, 0xff, 0xff, 0xff, 0x0, 0x0, 0x0, 0xff, 0xff, 0xff, 0x0, 0x0, 0x0, 
0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xff, 0xff, 0xff, 0x0, 0x0, 0x0, 0xff, 0xff, 0xff, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xff, 0xff, 0xff, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 
0x0, 0x0, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x0, 0x0, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x0, 0x0, 
0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x0, 0x0, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x0, 0x0, 0x0, 0x80, 0x80, 
0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 
0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 
0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 
0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0, 0x80, 0x80, 
0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 
0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 
0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 
0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 
0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 
0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 
0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 
0x0, 0x80, 0x80, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 
0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 
0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 
0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 
0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 
0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 
0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0x0, 0x80, 0x80, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff

};

/////////////////////////////////////////////////////
/// Function: InitialiseODETexture
/// Params: None
///
/////////////////////////////////////////////////////
void physics::InitialiseODETexture()
{
	glGenTextures( 1, &physicsTexture );
	renderer::OpenGL::GetInstance()->BindTexture( physicsTexture );

	glTexParameterf( GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT );
	glTexParameterf( GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT );
	glTexParameterf( GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR );
	glTexParameterf( GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR );
	glTexImage2D( GL_TEXTURE_2D, 0, GL_RGB, 32, 32, 0, GL_RGB, GL_UNSIGNED_BYTE, physics_texture );
}

/////////////////////////////////////////////////////
/// Function: ReleaseODETexture
/// Params: None
///
/////////////////////////////////////////////////////
void physics::ReleaseODETexture()
{
	if( physicsTexture != renderer::INVALID_OBJECT )
	{
		renderer::RemoveTexture( physicsTexture );
		physicsTexture = renderer::INVALID_OBJECT;
	}
}

/////////////////////////////////////////////////////
/// Function: BindODETexture
/// Params: None
///
/////////////////////////////////////////////////////
void physics::BindODETexture()
{
	if( physicsTexture != renderer::INVALID_OBJECT )
		renderer::OpenGL::GetInstance()->BindTexture( physicsTexture );
}

#endif // BASE_ENABLE_ODE_TEXTURE

#endif // defined(BASE_SUPPORT_OPENGL) || defined(BASE_SUPPORT_OPENGLES)
#endif // BASE_SUPPORT_ODE
